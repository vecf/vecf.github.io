<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <title>title</title>
  <style type="text/css">
      code{white-space: pre-wrap;}
      span.smallcaps{font-variant: small-caps;}
      span.underline{text-decoration: underline;}
      div.column{display: inline-block; vertical-align: top; width: 50%;}
  </style>
  <link rel="stylesheet" href="template.css" />
</head>
<body>
<h1 id="description">Description</h1>
<p>This article is a run through of my <a href="./media/masters/thesis.pdf">master’s thesis</a> from which <a href="https://doi.org/10.1007/s11370-021-00350-1">this publication</a> is derived. This work deals with coordinating multiple robots in online order fulfilment systems.</p>
<h1 id="visiting-pebbles-on-rectangular-grids---the-ideas">Visiting Pebbles on Rectangular Grids - The Ideas</h1>
<p>The name was inspired by <a href="https://doi.org/10.1109/SFCS.1984.715921">Kornhauser et al</a>’s work entitled <em>Coordinating Pebble Motion On Graphs</em> (PMOG). <strong>Abstractly</strong>, pebbles represent agents requiring access to shared resources. <a href="https://en.wikipedia.org/wiki/Graph_theory">Graph</a> nodes represent the shared resources. Specifically, only one pebble can access a node at a time. The goal of PMOG is to determine whether a target configuration is reachable from the initial arrangement of pebbles and provide the sequence of required moves if it is.</p>
<p><strong>Concretely</strong>, PMOG is applicable in robotic warehousing systems: the pebbles represent robots that access physical locations. This example is not as far fetched as it sounds: thousands of robots are delivering packages from storage to packing stations in warehouses every day and Kiva Systems is the company that pioneered their use. It’s also not new: Staples was the first company to go live with a Kiva system in 2006! A 2016 report estimated that Amazon was operating ~30k units. The image below shows the layout of a typical robotic distribution center.</p>
<figure>
<img src="media/masters/kivaLayout.png" alt="Distribution Center Layout (image source)" /><figcaption>Distribution Center Layout (<a href="https://dl.acm.org/doi/abs/10.5555/2908675.2908681">image source</a>)</figcaption>
</figure>
<p>Robots pick up and deliver shelves of inventory to pick/pack workers in the Kiva system as shown below.</p>
<figure>
<img src="media/masters/kivabot.png" alt="Kiva Robot Carrying Inventory Pod (image source)" /><figcaption>Kiva Robot Carrying Inventory Pod (<a href="https://dl.acm.org/doi/abs/10.5555/2908675.2908681">image source</a>)</figcaption>
</figure>
<p>PMOG generalizes and solves a fundamental problem. However, the constraints could be relaxed for this application: robots only need to <strong>visit</strong> destination nodes, they don’t need to be in a pre-defined end configuration at the same time. <strong>Hence the ‘visiting’ part of the title.</strong></p>
<p>This relaxation has implications for the feasibility check of the original PMOG: it’s easy to come up with feasible visiting PMOG cases that are infeasible in PMOG. Since warehouses are rectangular workspaces, my work is restricted to graphs made up of <a href="https://en.wikipedia.org/wiki/Biconnected_graph">bi-connected</a> rectangular grids. As long as there is at least one open node and the graph is bi-connected, every destination assignment is feasible in <strong>Visiting Pebble Motion on Rectangual Grids.</strong></p>
<h1 id="the-implementation">The Implementation</h1>
<h2 id="a-first-try">A first try</h2>
<p>Let robots find their way using something like <a href="https://en.wikipedia.org/wiki/A*_search_algorithm">A*</a>, if another robot gets in the way, simply wait until the node is free again. Using the <a href="https://research.csc.ncsu.edu/alphabetsoup/">Alphabet Soup</a> multi-robot simulator, I modified the default behaviour to strictly adhere to the underlying navigation graph. Then, I only allowed robots to enter a node if it is empty. The snapshot below shows what it looked like: the robots are pink, replenishing stations are blue, shelves are purple and packing stations are green. The shelves contain letters and the parcels being packed are words from a dictionary.</p>
<video alt="Alphabet Soup Simulation of Distribution Centre" controls>
<source src="media/masters/soup.mp4" type="video/mp4">
</video>
<p>There is a problem though: eventually the robots get stuck waiting for each other as shown in the image below. This is known as <a href="https://en.wikipedia.org/wiki/Deadlock">deadlock</a>.</p>
<figure>
<img src="media/masters/deadlock.png" alt="Robots in an infinite wait" /><figcaption>Robots in an infinite wait</figcaption>
</figure>
<h2 id="a-step-back---dealing-with-deadlocks-one-at-a-time.">A step back - dealing with deadlocks… one at a time.</h2>
<p>Let’s focus on a single robot that is stuck and assume it can order others to move out of its way. A <a href="https://en.wikipedia.org/wiki/Breadth-first_search">Breadth First Search</a> (BFS) for the first open node reveals the shortest path of moves to clear the blocked node (i.e the ‘swap path’). The process is shown below. In some cases, robots start in their target positions, or reach them by moving out of the way for others, this is a <a href="https://en.wikipedia.org/wiki/Serendipity">fortunate accident</a>.</p>
<figure>
<img src="media/masters/algo.gif" alt="Visiting Pebble Motion Algorithm Demonstration" /><figcaption>Visiting Pebble Motion Algorithm Demonstration</figcaption>
</figure>
<p>The video below shows a simulator written in Java to develop the deadlock resolution strategy. Square brackets represent grid positions and numbers represent robots. Each node is the target of the robot with the same number and the grid is numbered in row major order, meaning if every robot were in its destination position, it would look like this:</p>
<pre><code>[ 1] [ 2] [ 3] [ 4]
[ 5] [ 6] [ 7] [ 8]
[ 9] [10] [11] [12]
[13] [14] [15] [16]</code></pre>
<p>The previously described process is repeated for every robot. The robot currently in control of all moves is indicated as ‘Moving pebble’ and all unfinished robots are shown in the ‘Pebbles queue’. The pebbles queue determines which robot gains control next and was populated randomly, since the order doesn’t matter. As expected, all robots eventually end up in ‘Completed’.</p>
<video width="320" height="240" controls>
<source src="media/masters/sync/sync_serial.mp4" type="video/mp4">
</video>
<h2 id="a-jump-forward---dealing-with-deadlocks-many-at-a-time.">A jump forward - dealing with deadlocks… many at a time.</h2>
<p>Simultaneous motion is achieved by assigning a priority to each robot and defining a round consisting of two phases. In a first phase, robots instruct each other to move along the swap path determined using BFS. A robot sends instructions either to itself or the robot at the tip of the swap path. Robots send instructions to themselves in two scenarios: 1) to move to the next node, and 2) to remain in place while ordering others to move. This ensures that high priority robots decrease their distance from their target monotonically, which in turn ensures that progress is being made. Idle robots don’t send instructions, but receive them. At the end of this phase, each robot selects the highest priority instruction and forwards it as a node access request, maintaining the original sender’s priority.</p>
<p>In the second phase, <strong>nodes</strong> select the highest priority request to notify successful requesters and these robots move. Then, all robots empty their instruction queues. This ends the round and the process repeats until all tasks are complete, at which point no one sends instructions and everything stops.</p>
<p>In the video below, the same task assignments are used as before. Lower numbers mean higher priorities, making life hard for robot 10!</p>
<video width="320" height="240" controls>
<source src="media/masters/sync/sync_parallel.mp4" type="video/mp4">
</video>
<h2 id="going-all-the-way---eliminating-the-synchronous-assumption.">Going all the way - eliminating the synchronous assumption.</h2>
<p>So far actions were synchronized into rounds and robots/nodes knew when the transitions occur. However, the real world is asynchronous and these timings aren’t known beforehand. Unavoidable variances mean that some robots are faster than others and it is wasteful to synchronize node transitions into fixed time slices. But, without a centralized synchronization signal, robots don’t know when to replan and nodes don’t know when to grant access.</p>
<p>The answer to reducing this waste is to notify robots when their instructions have failed. Nodes notify all requesters when access is granted, and requesters react accordingly. Failed requests are relayed by the requesters to their originators. Instructed robots don’t know whether their instruction queues already contain the highest priority instruction they will get, so they immediately request what they have, and update accordingly when new requests arrive by withdrawing/resubmitting requests.</p>
<p>Getting the programming right is <strong>really difficult</strong>. Instead of wading through the gory details, let’s see it in action! The grid in the video below has tasks assigned in row major order. Robots indicate completion by highlighting themselves in red and indicate node visits by marking them with a purple circle. These robots have randomly initialized acceleration and speed limits to simulate real-world variances.</p>
<video width="320" height="240" controls>
<source src="media/masters/async/rowmajor.mp4" type="video/mp4">
</video>
<p>Note that any task assignment is allowed. In fact, robots can even all have the same target node as shown below. In fact, this is an example of an infeasible PMOG assignment.</p>
<video width="320" height="240" controls>
<source src="media/masters/async/central.mp4" type="video/mp4">
</video>
<p>So far only single tasks were assigned. Multiple tasks can be assigned by setting the robot’s priority equal to the task number. Even if one task is delayed by many others, as overriding tasks complete, the blocked task’s priority effectively raises until it overrides every other robot. The video below shows robots cyclically completing multiple random node visits.</p>
<video width="320" height="240" controls>
<source src="media/masters/async/random_cyclic.mp4" type="video/mp4">
</video>
<h2 id="a-final-test">A Final Test</h2>
<p>Using the random cyclic task assignments, the figure below shows the number of completed missions versus number of robots for one hour of simulated time, 144 grid nodes and up to 143 robots. The legend indicates experiments for grids with different aspect ratios.</p>
<figure>
<img src="media/masters/tasks_completed.png" alt="Completed tasks vs number of robots and board" /><figcaption>Completed tasks vs number of robots and board</figcaption>
</figure>
<p>The maximum number of completed tasks always occurs for around 30 robots independent of the grid aspect ratio. The simulations were run headless and no deadlocks or collisions occurred, that’s 1001 flawless simulations!</p>
<h1 id="conclusion">Conclusion</h1>
<p>The relaxations on PMOG allows robots to deliver payloads without collisions or deadlocks, in continuous asynchronous time and require comparatively little computation. These were the extents of my research scope and there is much room for improvement in terms of optimality. However, I am proud of what I achieved and am glad to have made a contribution to robotics research, however big or small.</p>
</body>
</html>
